import { initTRPC } from '@trpc/server'
import { z } from 'zod'
import { prisma } from '@nsm/db'
import { Queue } from 'bullmq'
import type { SiteStatus } from '@prisma/client'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/server/auth'
import { encrypt, fetchJson, WpSnapshot, decrypt, hmacSHA256Base64 } from '@nsm/core'
import { cookies } from 'next/headers'

export async function createContext() {
  const session = await getServerSession(authOptions)
  let accountId: string | null = null
  let impersonated = false
  try {
    if (session?.user?.email) {
      const user = await prisma.user.findUnique({ where: { email: session.user.email } })
      if (user) {
        const membership = await prisma.membership.findFirst({ where: { userId: user.id } })
        if (membership) {
          accountId = membership.accountId
        } else {
          const acc = await prisma.account.create({ data: { name: `Personal - ${user.email}`, plan: 'free' } })
          await prisma.membership.create({ data: { accountId: acc.id, userId: user.id, role: 'owner' } })
          accountId = acc.id
        }
      }
    }
    // Super admin impersonation via cookie
    try {
      const role = (session as any)?.user?.role
      const c = cookies()
      const imp = c.get('impersonateAccountId')?.value
      if (role === 'admin' && imp) {
        const acc = await prisma.account.findUnique({ where: { id: imp } })
        if (acc) { accountId = acc.id; impersonated = true }
      }
    } catch {}
  } catch (e) {
    console.error('createContext provisioning error:', e)
  }
  return { session, accountId, impersonated }
}

const t = initTRPC.context<Awaited<ReturnType<typeof createContext>>>().create()
export const router = t.router
export const publicProcedure = t.procedure
const isAuthed = t.middleware(({ ctx, next }) => {
  if (!ctx.session) throw new Error('UNAUTHORIZED')
  return next({ ctx })
})
const isAdmin = t.middleware(({ ctx, next }) => {
  const role = (ctx.session as any)?.user?.role
  if (role !== 'admin') throw new Error('FORBIDDEN')
  return next({ ctx })
})
export const protectedProcedure = t.procedure.use(isAuthed)
export const adminProcedure = t.procedure.use(isAuthed).use(isAdmin)

const PageInput = z.object({ page: z.number().int().min(1).default(1), pageSize: z.number().int().min(1).max(200).default(50) })
const SitesListInput = z.object({
  q: z.string().optional(),
  tags: z.array(z.string()).optional(),
  statuses: z.array(z.enum(['ok','unreachable','auth_failed','unknown'] as const)).optional(),
  sort: z.enum(['createdAt','lastCheckedAt','name','url','status','severity']).default('createdAt').optional(),
  order: z.enum(['asc','desc']).default('desc').optional(),
}).merge(PageInput).optional()

// Helper: fetch status from WP site and record a Check + statuses
async function refreshStatusForSite(site: any) {
  try {
    let headers: Record<string,string> = {}
    if (site.authType === 'bearer_token' && site.bearerTokenEnc) headers['Authorization'] = 'Bearer ' + await decrypt(site.bearerTokenEnc)
    if (site.authType === 'app_password' && site.appPasswordEnc && site.username) {
      const cred = await decrypt(site.appPasswordEnc)
      headers['Authorization'] = 'Basic ' + Buffer.from(`${site.username}:${cred}`).toString('base64')
    }
    const url = new URL('/wp-json/ns-monitor/v1/status', site.url).toString()
    const data = await fetchJson<WpSnapshot>(url, { headers, timeoutMs: 12000 })

    const check = await prisma.check.create({ data: { siteId: site.id, ok: true, startedAt: new Date(), finishedAt: new Date() } })
    await prisma.coreStatus.create({
      data: {
        checkId: check.id,
        currentVersion: data.core.currentVersion,
        latestVersion: data.core.latestVersion,
        updateAvailable: data.core.updateAvailable,
        security: data.core.security,
      }
    })
    await prisma.$transaction(data.plugins.map(p => prisma.pluginStatus.create({
      data: {
        checkId: check.id,
        slug: p.slug,
        name: p.name,
        currentVersion: p.currentVersion,
        latestVersion: p.latestVersion,
        updateAvailable: p.updateAvailable,
        security: p.security,
        hasChangelog: !!p.hasChangelog,
        changelogUrl: p.changelogUrl || null,
      }
    })))

    const hasAnyUpdate = data.core.updateAvailable || data.plugins.some(p => p.updateAvailable)
    const hasSecurityUpdate = data.core.security || data.plugins.some(p => p.security)
    const hasChangelog = data.core.updateAvailable || data.plugins.some(p => p.hasChangelog)

    await prisma.site.update({ where: { id: site.id }, data: {
      lastCheckedAt: new Date(),
      status: 'ok',
      hasAnyUpdate,
      hasSecurityUpdate,
      hasChangelog
    }})
  } catch (e) {
    await prisma.logEntry.create({ data: { siteId: site.id, level: 'warn', message: 'Refresh after update failed', payload: { error: (e as any)?.message || String(e) } as any } })
  }
}
async function ensureAccountManager(ctx: Awaited<ReturnType<typeof createContext>>) {
  const email = (ctx.session as any)?.user?.email
  if (!email || !ctx.accountId) throw new Error('FORBIDDEN')
  const user = await prisma.user.findUnique({ where: { email } })
  if (!user) throw new Error('FORBIDDEN')
  const membership = await prisma.membership.findFirst({ where: { accountId: ctx.accountId, userId: user.id } })
  if (!membership) throw new Error('FORBIDDEN')
  if (membership.role === 'owner' || membership.role === 'admin') return true
  throw new Error('FORBIDDEN')
}

export const appRouter = router({
  accounts: router({
    me: protectedProcedure.query(async ({ ctx }) => {
      if (!ctx.accountId) return null
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId } })
      return acc
    }),
    stats: router({
      me: protectedProcedure.query(async ({ ctx }) => {
        if (!ctx.accountId) return null
        const acc = await prisma.account.findUnique({ where: { id: ctx.accountId } })
        if (!acc) return null
        const seatsUsed = await prisma.membership.count({ where: { accountId: ctx.accountId } })
        const now = new Date()
        const day = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()))
        const usage = await prisma.accountUsage.findUnique({ where: { accountId_day: { accountId: ctx.accountId, day } } })
        return {
          seatsUsed,
          seatsMax: acc.seatsMax,
          checksToday: usage?.checks ?? 0,
          checksPerDay: acc.checksPerDay,
        }
      })
    }),
    list: adminProcedure.query(async () => {
      const accounts = await prisma.account.findMany({ include: { _count: { select: { sites: true, members: true } } } })
      return accounts
    }),
    impersonation: router({
      status: adminProcedure.query(async ({ ctx }) => {
        if (!ctx.accountId) return { active: false }
        const acc = await prisma.account.findUnique({ where: { id: ctx.accountId } })
        return { active: !!ctx.impersonated, accountId: ctx.accountId, accountName: acc?.name }
      })
    }),
    membership: router({
      me: protectedProcedure.query(async ({ ctx }) => {
        if (!ctx.accountId) return null
        const email = (ctx.session as any)?.user?.email
        if (!email) return null
        const user = await prisma.user.findUnique({ where: { email } })
        if (!user) return null
        const mem = await prisma.membership.findFirst({ where: { accountId: ctx.accountId, userId: user.id } })
        return mem ? { role: mem.role } : null
      })
    }),
  self: router({
    setInvite: protectedProcedure.input(z.object({ canMembersInvite: z.boolean() })).mutation(async ({ input, ctx }) => {
      if (!ctx.accountId) throw new Error('NO_ACCOUNT')
      const email = (ctx.session as any)?.user?.email
      const user = email ? await prisma.user.findUnique({ where: { email } }) : null
      const mem = user ? await prisma.membership.findFirst({ where: { accountId: ctx.accountId, userId: user.id } }) : null
      if (!mem || (mem.role !== 'owner' && mem.role !== 'admin')) throw new Error('FORBIDDEN')
      await prisma.account.update({ where: { id: ctx.accountId }, data: { canMembersInvite: input.canMembersInvite } })
      return { ok: true }
    }),
    changePassword: protectedProcedure.input(z.object({ oldPassword: z.string().min(6), newPassword: z.string().min(6) })).mutation(async ({ input, ctx }) => {
      const email = (ctx.session as any)?.user?.email
      if (!email) throw new Error('UNAUTHORIZED')
      const user = await prisma.user.findUnique({ where: { email } })
      if (!user) throw new Error('UNAUTHORIZED')
      // verify old password
      const [saltHex, hashHex] = user.passwordHash.split('.')
      if (!saltHex || !hashHex) throw new Error('PASSWORD_FORMAT')
      const { scryptSync, timingSafeEqual, randomBytes } = await import('crypto')
      const saltBuf = Buffer.from(saltHex, 'hex')
      const hashBuf = Buffer.from(hashHex, 'hex')
      const test = scryptSync(input.oldPassword, saltBuf, hashBuf.length)
      if (!timingSafeEqual(hashBuf, test)) throw new Error('INVALID_OLD_PASSWORD')
      // set new password
      const newSalt = randomBytes(16)
      const newHash = scryptSync(input.newPassword, newSalt, 64)
      const passwordHash = `${newSalt.toString('hex')}.${newHash.toString('hex')}`
      await prisma.user.update({ where: { id: user.id }, data: { passwordHash } })
      return { ok: true }
    })
  }),
    members: router({
      setRole: adminProcedure.input(z.object({ accountId: z.string(), userId: z.string(), role: z.enum(['owner','admin','member']) })).mutation(async ({ input }) => {
        await prisma.membership.update({
          where: { accountId_userId: { accountId: input.accountId, userId: input.userId } },
          data: { role: input.role as any }
        })
        return { ok: true }
      }),
      add: adminProcedure.input(z.object({ accountId: z.string(), email: z.string().email(), role: z.enum(['owner','admin','member']).default('member') })).mutation(async ({ input }) => {
        const acc = await prisma.account.findUnique({ where: { id: input.accountId } })
        if (!acc) throw new Error('ACCOUNT_NOT_FOUND')
        const seats = await prisma.membership.count({ where: { accountId: input.accountId } })
        if (acc && seats >= acc.seatsMax) throw new Error('SEAT_LIMIT_REACHED')
        let user = await prisma.user.findUnique({ where: { email: input.email } })
        if (!user) {
          const { randomBytes, scryptSync } = await import('crypto')
          const salt = randomBytes(16)
          const hash = scryptSync(randomBytes(10).toString('hex'), salt, 64)
          user = await prisma.user.create({ data: { email: input.email, role: 'viewer', passwordHash: `${salt.toString('hex')}.${hash.toString('hex')}` } })
        }
        await prisma.membership.upsert({
          where: { accountId_userId: { accountId: input.accountId, userId: user.id } },
          update: { role: input.role as any },
          create: { accountId: input.accountId, userId: user.id, role: input.role as any }
        })
        return { ok: true }
      }),
      remove: adminProcedure.input(z.object({ accountId: z.string(), userId: z.string() })).mutation(async ({ input }) => {
        await prisma.membership.delete({ where: { accountId_userId: { accountId: input.accountId, userId: input.userId } } })
        return { ok: true }
      })
    })
  }),
  members: router({
    list: protectedProcedure.query(async ({ ctx }) => {
      if (!ctx.accountId) return []
      const members = await prisma.membership.findMany({ where: { accountId: ctx.accountId }, include: { user: true } })
      return members.map(m => ({ id: m.id, role: m.role, user: { id: m.user.id, email: m.user.email } }))
    }),
    add: protectedProcedure.input(z.object({ email: z.string().email(), role: z.enum(['owner','admin','member']).default('member') })).mutation(async ({ input, ctx }) => {
      let accountId = ctx.accountId
      if (!accountId) {
        // Attempt auto-provision of an account for current user
        const emailSelf = ctx.session?.user?.email
        if (!emailSelf) throw new Error('NO_ACCOUNT')
        const self = await prisma.user.findUnique({ where: { email: emailSelf } })
        if (!self) throw new Error('NO_ACCOUNT')
        const existing = await prisma.membership.findFirst({ where: { userId: self.id } })
        if (existing) {
          accountId = existing.accountId
        } else {
          const acc = await prisma.account.create({ data: { name: `Personal - ${emailSelf}`, plan: 'free' } })
          await prisma.membership.create({ data: { accountId: acc.id, userId: self.id, role: 'owner' } })
          accountId = acc.id
        }
      }
      if (!accountId) throw new Error('NO_ACCOUNT')
      // enforce seats limit and permissions
      const acc = await prisma.account.findUnique({ where: { id: accountId } })
      const seats = await prisma.membership.count({ where: { accountId } })
      if (acc && seats >= acc.seatsMax) throw new Error('SEAT_LIMIT_REACHED')
      // who is adding?
      const callerEmail = ctx.session?.user?.email!
      const caller = await prisma.user.findUnique({ where: { email: callerEmail } })
      const callerMem = caller ? await prisma.membership.findFirst({ where: { accountId, userId: caller.id } }) : null
      const callerIsManager = !!callerMem && (callerMem.role === 'owner' || callerMem.role === 'admin')
      if (!callerIsManager && !acc?.canMembersInvite) throw new Error('FORBIDDEN')
      const assignedRole = callerIsManager ? input.role : 'member'
      let user = await prisma.user.findUnique({ where: { email: input.email } })
      if (!user) {
        const { randomBytes, scryptSync } = await import('crypto')
        const salt = randomBytes(16)
        const hash = scryptSync(randomBytes(10).toString('hex'), salt, 64)
        user = await prisma.user.create({ data: { email: input.email, role: 'viewer', passwordHash: `${salt.toString('hex')}.${hash.toString('hex')}` } })
      }
      await prisma.membership.upsert({
        where: { accountId_userId: { accountId, userId: user.id } },
        update: { role: assignedRole as any },
        create: { accountId, userId: user.id, role: assignedRole as any }
      })
      return { ok: true }
    }),
    remove: protectedProcedure.input(z.object({ userId: z.string() })).mutation(async ({ input, ctx }) => {
      if (!ctx.accountId) throw new Error('NO_ACCOUNT')
      await prisma.membership.delete({ where: { accountId_userId: { accountId: ctx.accountId, userId: input.userId } } })
      return { ok: true }
    })
  }),
  settings: router({
    get: adminProcedure.query(async () => {
      const rows = await prisma.setting.findMany()
      const map: Record<string, any> = {}
      for (const r of rows) map[r.key] = r.value
      return map
    }),
    set: adminProcedure.input(z.object({ key: z.string(), value: z.any() })).mutation(async ({ input }) => {
      await prisma.setting.upsert({ where: { key: input.key }, update: { value: input.value }, create: { key: input.key, value: input.value } })
      return { ok: true }
    }),
    rotateSecrets: adminProcedure.input(z.object({ oldKeyB64: z.string(), newKeyB64: z.string() })).mutation(async ({ input }) => {
      // Re-encrypt all site secrets using provided keys
      const { parseKeyB64, decryptWithKey, encryptWithKey } = await import('@nsm/core') as any
      const oldKey = parseKeyB64(input.oldKeyB64)
      const newKey = parseKeyB64(input.newKeyB64)
      const sites = await prisma.site.findMany({ select: { id: true, appPasswordEnc: true, bearerTokenEnc: true, webhookSecretEnc: true } })
      for (const s of sites) {
        const data: any = {}
        if (s.appPasswordEnc) data.appPasswordEnc = await encryptWithKey(await decryptWithKey(s.appPasswordEnc, oldKey), newKey)
        if (s.bearerTokenEnc) data.bearerTokenEnc = await encryptWithKey(await decryptWithKey(s.bearerTokenEnc, oldKey), newKey)
        if (s.webhookSecretEnc) data.webhookSecretEnc = await encryptWithKey(await decryptWithKey(s.webhookSecretEnc, oldKey), newKey)
        if (Object.keys(data).length) await prisma.site.update({ where: { id: s.id }, data })
      }
      // Store a hint of rotation time (no secrets)
      await prisma.setting.upsert({ where: { key: 'encryption.rotatedAt' }, update: { value: new Date() as any }, create: { key: 'encryption.rotatedAt', value: new Date() as any } })
      return { ok: true }
    })
  }),
  sites: router({
    list: protectedProcedure.input(SitesListInput).query(async ({ input, ctx }) => {
      const page = input?.page ?? 1
      const pageSize = input?.pageSize ?? 50
      const where: any = {}
      if (input?.q) where.OR = [
        { name: { contains: input.q, mode: 'insensitive' } },
        { url: { contains: input.q, mode: 'insensitive' } },
      ]
      if (input?.tags?.length) {
        const tagFilters = (input.tags as string[]).map(t => ({ tags: { array_contains: t as any } }))
        where.AND = [...(where.AND || []), { OR: tagFilters }]
      }
      if (input?.statuses?.length) where.status = { in: input.statuses as SiteStatus[] }

      // Build server ordering
      const sort = input?.sort ?? 'createdAt'
      const order = input?.order ?? 'desc'
      const prismaOrder: any = (() => {
        if (sort === 'severity') {
          // Highest severity first: security updates > any updates > others; then lastCheckedAt desc
          return [
            { hasSecurityUpdate: 'desc' },
            { hasAnyUpdate: 'desc' },
            { lastCheckedAt: 'desc' },
          ]
        }
        if (sort === 'name' || sort === 'url' || sort === 'status' || sort === 'createdAt' || sort === 'lastCheckedAt') {
          return { [sort]: order }
        }
        return { createdAt: 'desc' }
      })()

      const [total, rawItems] = await Promise.all([
        prisma.site.count({ where: { ...where, accountId: ctx.accountId! } }),
        prisma.site.findMany({
          where: { ...where, accountId: ctx.accountId! },
          orderBy: prismaOrder,
          skip: (page - 1) * pageSize,
          take: pageSize,
          include: { _count: { select: { logs: true } } }
        })
      ])
      // Compute latest update counts per site (core + plugins needing update)
      const items = [] as any[]
      for (const it of rawItems) {
        const latest = await prisma.check.findFirst({
          where: { siteId: it.id },
          orderBy: { startedAt: 'desc' },
          include: { core: true, plugins: { where: { updateAvailable: true }, select: { id: true } } }
        })
        const updateCount = (latest?.core?.updateAvailable ? 1 : 0) + (latest?.plugins?.length ?? 0)
        items.push({ ...it, updateCount })
      }
      return { items, total, page, pageSize }
    }),
    detail: protectedProcedure.input(z.object({ id: z.string() })).query(async ({ input, ctx }) => {
      const site = await prisma.site.findFirst({ where: { id: input.id, accountId: ctx.accountId! } })
      if (!site) return null
      const latestCheck = await prisma.check.findFirst({ where: { siteId: site.id }, orderBy: { startedAt: 'desc' }, include: { core: true, plugins: true } })
      const logsCount = await prisma.logEntry.count({ where: { siteId: site.id } })
      return { site, latestCheck, logsCount }
    }),
    create: protectedProcedure.input(z.object({
      name: z.string().min(1),
      url: z.string().url(),
      authType: z.enum(['app_password','bearer_token']),
      username: z.string().optional(),
      credential: z.string().optional(),
      tags: z.array(z.string()).default([])
    })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      if (!ctx.accountId) throw new Error('NO_ACCOUNT')
      // trial gating
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      // enforce site limits
      const current = await prisma.site.count({ where: { accountId: ctx.accountId } })
      if (acc && acc.maxSites >= 0 && current >= acc.maxSites) throw new Error('SITE_LIMIT_REACHED')
      const data: any = { accountId: ctx.accountId, name: input.name, url: input.url, authType: input.authType, username: input.username, tags: input.tags }
      if (input.authType === 'bearer_token' && input.credential) data.bearerTokenEnc = await encrypt(input.credential)
      if (input.authType === 'app_password' && input.credential) data.appPasswordEnc = await encrypt(input.credential)
      data.webhookSecretEnc = await encrypt('auto-' + Math.random().toString(36).slice(2))
      return prisma.site.create({ data })
    }),
    update: protectedProcedure.input(z.object({
      id: z.string(),
      name: z.string().min(1),
      url: z.string().url(),
      authType: z.enum(['app_password','bearer_token']),
      username: z.string().optional().nullable(),
      credential: z.string().optional().nullable(),
      tags: z.array(z.string()).default([])
    })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      const { id, ...rest } = input
      const { credential, ...fields } = rest as any
      const data: any = { ...fields }
      // Do not persist raw credential; only encrypted form
      if (credential) {
        if (fields.authType === 'bearer_token') data.bearerTokenEnc = await encrypt(credential)
        if (fields.authType === 'app_password') data.appPasswordEnc = await encrypt(credential)
      }
      const owned = await prisma.site.findFirst({ where: { id, accountId: ctx.accountId! } })
      if (!owned) throw new Error('NOT_FOUND')
      return prisma.site.update({ where: { id }, data })
    }),
    bulkTag: protectedProcedure.input(z.object({
      ids: z.array(z.string()).min(1),
      add: z.array(z.string()).default([]).optional(),
      remove: z.array(z.string()).default([]).optional(),
    })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      const ops: any[] = []
      if (input.add && input.add.length) {
        const sites = await prisma.site.findMany({ where: { id: { in: input.ids } }, select: { id: true, tags: true } })
        for (const s of sites) {
          const existing: string[] = Array.isArray(s.tags) ? (s.tags as any) : []
          const merged = Array.from(new Set([...(existing || []), ...input.add]))
          ops.push(prisma.site.update({ where: { id: s.id }, data: { tags: merged as any } }))
        }
      }
      if (input.remove && input.remove.length) {
        // Prisma lacks array remove; fetch and set filtered tags
        const sites = await prisma.site.findMany({ where: { id: { in: input.ids } }, select: { id: true, tags: true } })
        for (const s of sites) {
          const next = (s.tags || []).filter(t => !input.remove!.includes(t))
          ops.push(prisma.site.update({ where: { id: s.id }, data: { tags: next } }))
        }
      }
      await prisma.$transaction(ops)
      return { ok: true }
    }),
    bulkCreate: protectedProcedure.input(z.object({
      sites: z.array(z.object({
        name: z.string().min(1),
        url: z.string().url(),
        authType: z.enum(['app_password','bearer_token']).default('bearer_token'),
        username: z.string().optional().nullable(),
        credential: z.string().optional().nullable(),
        tags: z.array(z.string()).default([])
      }))
    })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      if (!ctx.accountId) throw new Error('NO_ACCOUNT')
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      let current = await prisma.site.count({ where: { accountId: ctx.accountId } })
      const results: { url: string; created: boolean }[] = []
      for (const s of input.sites) {
        if (acc && acc.maxSites >= 0 && current >= acc.maxSites) {
          results.push({ url: s.url, created: false })
          continue
        }
        const data: any = { name: s.name, url: s.url, authType: s.authType, username: s.username || undefined, tags: s.tags || [] }
        if (s.credential) {
          if (s.authType === 'bearer_token') data.bearerTokenEnc = await encrypt(s.credential)
          if (s.authType === 'app_password') data.appPasswordEnc = await encrypt(s.credential)
        }
        data.webhookSecretEnc = await encrypt('auto-' + Math.random().toString(36).slice(2))
        const exists = await prisma.site.findFirst({ where: { url: s.url, accountId: ctx.accountId } })
        if (exists) {
          await prisma.site.update({ where: { url: s.url }, data })
          results.push({ url: s.url, created: false })
        } else {
          await prisma.site.create({ data: { ...data, accountId: ctx.accountId } })
          current += 1
          results.push({ url: s.url, created: true })
        }
      }
      return { ok: true, results }
    }),
    remove: protectedProcedure.input(z.object({ id: z.string() })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      await prisma.site.delete({ where: { id: input.id } })
      return { ok: true }
    }),
    testConnection: protectedProcedure.input(z.object({
      url: z.string().url(),
      authType: z.enum(['app_password','bearer_token']),
      username: z.string().optional(),
      credential: z.string().optional()
    })).mutation(async ({ input, ctx }) => {
      await ensureAccountManager(ctx)
      let { username, credential } = input
      if (!credential) {
        // Try to load saved credential for this site by URL
        const site = await prisma.site.findUnique({ where: { url: input.url } })
        if (site) {
          if (input.authType === 'bearer_token' && site.bearerTokenEnc) credential = await decrypt(site.bearerTokenEnc)
          if (input.authType === 'app_password' && site.appPasswordEnc) credential = await decrypt(site.appPasswordEnc)
          if (!username && site.username) username = site.username
        }
      }
      const headers: Record<string,string> = {}
      if (input.authType === 'bearer_token' && credential) headers['Authorization'] = `Bearer ${credential}`
      if (input.authType === 'app_password' && username && credential) headers['Authorization'] = 'Basic ' + Buffer.from(`${username}:${credential}`).toString('base64')
      const url = new URL('/wp-json/ns-monitor/v1/status', input.url).toString()
      try {
        const data = await fetchJson<WpSnapshot>(url, { headers, timeoutMs: 6000 })
        return { ok: true, core: data.core, plugins: data.plugins.length }
      } catch (e: any) {
        return { ok: false, error: e?.message || 'Request failed' }
      }
    })
  }),
  logs: router({
    list: protectedProcedure.input(z.object({ siteId: z.string() }).merge(PageInput)).query(async ({ input, ctx }) => {
      const page = input.page
      const pageSize = input.pageSize
      const site = await prisma.site.findFirst({ where: { id: input.siteId, accountId: ctx.accountId! } })
      if (!site) return { items: [], total: 0, page, pageSize }
      const where = { siteId: input.siteId }
      const [total, items] = await Promise.all([
        prisma.logEntry.count({ where }),
        prisma.logEntry.findMany({ where, orderBy: { createdAt: 'desc' }, skip: (page-1)*pageSize, take: pageSize })
      ])
      return { items, total, page, pageSize }
    }),
  }),
  checks: router({
    trigger: adminProcedure.input(z.object({ siteId: z.string() })).mutation(async ({ input, ctx }) => {
      const site = await prisma.site.findFirst({ where: { id: input.siteId, accountId: ctx.accountId! } })
      if (!site) throw new Error('NOT_FOUND')
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId! } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      const queue = new Queue('site-checks', { connection: { url: process.env.REDIS_URL! } })
      await queue.add('checkSite', { siteId: input.siteId }, { removeOnComplete: true, removeOnFail: true })
      await queue.close()
      return { ok: true }
    }),
    history: protectedProcedure.input(z.object({ siteId: z.string(), limit: z.number().int().min(1).max(100).default(20) })).query(async ({ input }) => {
      const checks = await prisma.check.findMany({ where: { siteId: input.siteId }, orderBy: { startedAt: 'desc' }, take: input.limit, include: { core: true, plugins: true } })
      const data = checks.map(c => ({
        date: c.startedAt,
        coreUpdate: c.core?.updateAvailable ?? false,
        securityCount: (c.plugins?.filter(p => p.security).length ?? 0) + (c.core?.security ? 1 : 0),
        updateCount: (c.plugins?.filter(p => p.updateAvailable).length ?? 0) + (c.core?.updateAvailable ? 1 : 0),
      }))
      return data.reverse()
  })
  }),
  updates: router({
    updateCore: protectedProcedure.input(z.object({ siteId: z.string() })).mutation(async ({ input, ctx }) => {
      const site = await prisma.site.findFirst({ where: { id: input.siteId, accountId: ctx.accountId! } })
      if (!site?.url || !site.webhookSecretEnc) throw new Error('NOT_FOUND')
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId! } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      const secret = await decrypt(site.webhookSecretEnc)
      const body = JSON.stringify({})
      const sig = hmacSHA256Base64(secret, body)
      const url = new URL('/wp-json/ns-monitor/v1/update/core', site.url).toString()
      const headers: Record<string,string> = { 'content-type': 'application/json', 'x-nsm-signature': sig }
      if ((site as any).authType === 'bearer_token' && (site as any).bearerTokenEnc) headers['authorization'] = 'Bearer ' + await decrypt((site as any).bearerTokenEnc)
      if ((site as any).authType === 'app_password' && (site as any).appPasswordEnc && (site as any).username) {
        const cred = await decrypt((site as any).appPasswordEnc)
        headers['authorization'] = 'Basic ' + Buffer.from(`${(site as any).username}:${cred}`).toString('base64')
      }
      const res = await fetch(url, { method: 'POST', headers: { ...headers, accept: 'application/json' }, body })
      if (!res.ok) {
        let detail = ''
        try { detail = await res.text() } catch {}
        throw new Error(`WP update failed (${res.status}): ${detail?.slice(0,200)}`)
      }
      let data: any = null
      try { data = await res.json() } catch {}
      await prisma.logEntry.create({ data: { siteId: site.id, level: 'info', message: 'Triggered core update', payload: { action: 'core', response: data } as any } })
      await refreshStatusForSite(site)
      return { ok: true, response: data }
    }),
    updateAll: protectedProcedure.input(z.object({ siteId: z.string() })).mutation(async ({ input }) => {
      const site = await prisma.site.findUnique({ where: { id: input.siteId } })
      if (!site?.url || !site.webhookSecretEnc) throw new Error('NOT_FOUND')
      const secret = await decrypt(site.webhookSecretEnc)
      const body = JSON.stringify({})
      const sig = hmacSHA256Base64(secret, body)
      const url = new URL('/wp-json/ns-monitor/v1/update/all', site.url).toString()
      const headers: Record<string,string> = { 'content-type': 'application/json', 'x-nsm-signature': sig }
      if ((site as any).authType === 'bearer_token' && (site as any).bearerTokenEnc) headers['authorization'] = 'Bearer ' + await decrypt((site as any).bearerTokenEnc)
      if ((site as any).authType === 'app_password' && (site as any).appPasswordEnc && (site as any).username) {
        const cred = await decrypt((site as any).appPasswordEnc)
        headers['authorization'] = 'Basic ' + Buffer.from(`${(site as any).username}:${cred}`).toString('base64')
      }
      const res = await fetch(url, { method: 'POST', headers: { ...headers, accept: 'application/json' }, body })
      if (!res.ok) {
        let detail = ''
        try { detail = await res.text() } catch {}
        throw new Error(`WP update-all failed (${res.status}): ${detail?.slice(0,200)}`)
      }
      let data: any = null
      try { data = await res.json() } catch {}
      await prisma.logEntry.create({ data: { siteId: site.id, level: 'info', message: 'Triggered update all (core + plugins)', payload: { action: 'all', response: data } as any } })
      await refreshStatusForSite(site)
      return { ok: true, response: data }
    }),
    updatePlugin: protectedProcedure.input(z.object({ siteId: z.string(), slug: z.string() })).mutation(async ({ input, ctx }) => {
      const site = await prisma.site.findFirst({ where: { id: input.siteId, accountId: ctx.accountId! } })
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId! } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      if (!site?.url || !site.webhookSecretEnc) throw new Error('NOT_FOUND')
      const secret = await decrypt(site.webhookSecretEnc)
      const body = JSON.stringify({ slug: input.slug })
      const sig = hmacSHA256Base64(secret, body)
      const url = new URL('/wp-json/ns-monitor/v1/update/plugin', site.url).toString()
      const headers: Record<string,string> = { 'content-type': 'application/json', 'x-nsm-signature': sig }
      if ((site as any).authType === 'bearer_token' && (site as any).bearerTokenEnc) headers['authorization'] = 'Bearer ' + await decrypt((site as any).bearerTokenEnc)
      if ((site as any).authType === 'app_password' && (site as any).appPasswordEnc && (site as any).username) {
        const cred = await decrypt((site as any).appPasswordEnc)
        headers['authorization'] = 'Basic ' + Buffer.from(`${(site as any).username}:${cred}`).toString('base64')
      }
      const res = await fetch(url, { method: 'POST', headers: { ...headers, accept: 'application/json' }, body })
      if (!res.ok) {
        let detail = ''
        try { detail = await res.text() } catch {}
        throw new Error(`WP plugin update failed (${res.status}): ${detail?.slice(0,200)}`)
      }
      let data: any = null
      try { data = await res.json() } catch {}
      await prisma.logEntry.create({ data: { siteId: site.id, level: 'info', message: `Triggered plugin update: ${input.slug}`, payload: { action: 'plugin', slug: input.slug, response: data } as any } })
      await refreshStatusForSite(site)
      return { ok: true, response: data }
    }),
    testPermissions: protectedProcedure.input(z.object({ siteId: z.string() })).mutation(async ({ input, ctx }) => {
      const site = await prisma.site.findFirst({ where: { id: input.siteId, accountId: ctx.accountId! } })
      const acc = await prisma.account.findUnique({ where: { id: ctx.accountId! } })
      if (acc?.plan === 'trial' && acc.trialEndsAt && acc.trialEndsAt < new Date()) throw new Error('TRIAL_EXPIRED')
      if (!site?.url || !site.webhookSecretEnc) throw new Error('NOT_FOUND')
      const secret = await decrypt(site.webhookSecretEnc)
      const body = JSON.stringify({})
      const sig = hmacSHA256Base64(secret, body)
      const url = new URL('/wp-json/ns-monitor/v1/update/test', site.url).toString()
      const headers: Record<string,string> = { 'content-type': 'application/json', 'x-nsm-signature': sig, accept: 'application/json' }
      if ((site as any).authType === 'bearer_token' && (site as any).bearerTokenEnc) headers['authorization'] = 'Bearer ' + await decrypt((site as any).bearerTokenEnc)
      if ((site as any).authType === 'app_password' && (site as any).appPasswordEnc && (site as any).username) {
        const cred = await decrypt((site as any).appPasswordEnc)
        headers['authorization'] = 'Basic ' + Buffer.from(`${(site as any).username}:${cred}`).toString('base64')
      }
      const res = await fetch(url, { method: 'POST', headers, body })
      if (!res.ok) {
        let detail = ''
        try { detail = await res.text() } catch {}
        throw new Error(`WP test failed (${res.status}): ${detail?.slice(0,200)}`)
      }
      let data: any = null
      try { data = await res.json() } catch {}
      await prisma.logEntry.create({ data: { siteId: site.id, level: 'info', message: 'Tested update permissions', payload: { action: 'test', response: data } as any } })
      return { ok: true, response: data }
    })
  })
})

export type AppRouter = typeof appRouter



