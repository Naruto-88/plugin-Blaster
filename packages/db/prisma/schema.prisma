generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Role {
  admin
  viewer
}

enum MembershipRole {
  owner
  admin
  member
}

enum Plan {
  trial
  free
  starter
  pro
  enterprise
}

enum SiteStatus {
  ok
  unreachable
  auth_failed
  unknown
}

enum LogLevel {
  info
  warn
  error
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  role         Role
  createdAt    DateTime @default(now())
  memberships  Membership[]
}

model Account {
  id            String        @id @default(cuid())
  name          String
  plan          Plan          @default(free)
  // Effective limits (plan defaults can be overridden per account)
  maxSites      Int           @default(10)
  checksPerDay  Int           @default(200)
  retentionDays Int           @default(90)
  seatsMax      Int           @default(5)
  trialEndsAt   DateTime?
  paypalSubscriptionId String?
  canMembersInvite Boolean    @default(false)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  members       Membership[]
  sites         Site[]
  usages        AccountUsage[]
}

model Membership {
  id        String         @id @default(cuid())
  account   Account        @relation(fields: [accountId], references: [id])
  accountId String
  user      User           @relation(fields: [userId], references: [id])
  userId    String
  role      MembershipRole @default(member)
  createdAt DateTime       @default(now())

  @@unique([accountId, userId])
  @@index([userId])
}

model Site {
  id              String      @id @default(cuid())
  account         Account     @relation(fields: [accountId], references: [id])
  accountId       String
  ownerUserId     String?
  name            String
  url             String
  authType        String      // 'app_password' | 'bearer_token'
  username        String?
  appPasswordEnc  String?
  bearerTokenEnc  String?
  webhookSecretEnc String?
  // Using JSON for MySQL instead of Postgres string[]
  tags            Json
  lastCheckedAt   DateTime?
  status          SiteStatus  @default(unknown)
  hasAnyUpdate    Boolean     @default(false)
  hasSecurityUpdate Boolean   @default(false)
  hasChangelog    Boolean     @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  checks          Check[]
  logs            LogEntry[]

  @@index([accountId])
  @@unique([accountId, url])
}

model Check {
  id         String   @id @default(cuid())
  site       Site     @relation(fields: [siteId], references: [id])
  siteId     String
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  ok         Boolean
  errorText  String?
  core       CoreStatus?
  plugins    PluginStatus[]

  @@index([siteId, startedAt])
}

model CoreStatus {
  id              String  @id @default(cuid())
  check           Check   @relation(fields: [checkId], references: [id])
  checkId         String  @unique
  currentVersion  String
  latestVersion   String
  updateAvailable Boolean
  security        Boolean
}

model PluginStatus {
  id              String @id @default(cuid())
  check           Check  @relation(fields: [checkId], references: [id])
  checkId         String
  slug            String
  name            String
  currentVersion  String
  latestVersion   String
  updateAvailable Boolean
  security        Boolean
  hasChangelog    Boolean
  changelogUrl    String?

  @@index([checkId])
  @@index([slug])
}

model LogEntry {
  id        String   @id @default(cuid())
  site      Site     @relation(fields: [siteId], references: [id])
  siteId    String
  createdAt DateTime @default(now())
  level     LogLevel
  message   String
  payload   Json

  @@index([siteId, createdAt])
}

model Setting {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model AccountUsage {
  id        String   @id @default(cuid())
  account   Account  @relation(fields: [accountId], references: [id])
  accountId String
  day       DateTime // store as UTC date at 00:00
  checks    Int      @default(0)

  @@unique([accountId, day])
  @@index([accountId, day])
}
